// Licensed under the zlib License. See LICENSE file in the project root.
// Tone Map FX â€” Separable Gaussian Blur (used for Clarity)
// Reusable for horizontal and vertical passes via BlurDirection parameter.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

// ---- Parameters (bound from FToneMapBlurPS::FParameters) ----
Texture2D    SourceTexture;
SamplerState SourceSampler;
float4       BufferSizeAndInvSize;   // xy = output size, zw = 1/output size
float2       BlurDirection;          // (1,0) = horizontal, (0,1) = vertical
float        BlurRadius;             // spread multiplier (default 8)
float4       SourceViewportRect;     // xy = Min, zw = Max (of source texture viewport)
float4       SourceExtentInv;        // xy = 1/source extent, zw = unused

// Maximum half-kernel radius in texels (caps GPU work; 3*sigma covers 99.7% of Gaussian mass)
#define BLUR_MAX_HALF_KERNEL 48

void GaussianBlurPS(float4 SvPosition : SV_POSITION, out float4 OutColor : SV_Target0)
{
	// Map SvPosition (output texel coords) to source texture UV
	float2 NormPos  = SvPosition.xy * BufferSizeAndInvSize.zw;
	float2 TexelPos = lerp(SourceViewportRect.xy, SourceViewportRect.zw, NormPos);
	float2 UV       = TexelPos * SourceExtentInv.xy;

	// Texel size in source UV space (1 texel step along blur direction)
	float2 TexelSize = SourceExtentInv.xy;

	float2 Epsilon  = TexelSize * 0.5;
	float2 ClampMin = Epsilon;
	float2 ClampMax = 1.0 - Epsilon;

	// BlurRadius is the Gaussian sigma in texels.
	// Sample at 1-texel intervals out to 3*sigma so every pixel contributes.
	// This eliminates the aliasing/echo artefact caused by sparse (sigma-spaced) sampling.
	float sigma    = max(BlurRadius, 0.5);
	float invSig2  = -0.5 / (sigma * sigma);
	int   halfK    = min(int(ceil(3.0 * sigma)), BLUR_MAX_HALF_KERNEL);

	float3 Result  = 0.0;
	float  TotalW  = 0.0;

	LOOP
	for (int i = -halfK; i <= halfK; ++i)
	{
		float  w      = exp(float(i * i) * invSig2);
		float2 SampleUV = clamp(UV + BlurDirection * TexelSize * float(i), ClampMin, ClampMax);
		Result  += Texture2DSample(SourceTexture, SourceSampler, SampleUV).rgb * w;
		TotalW  += w;
	}

	OutColor = float4(Result / max(TotalW, 1e-6), 1.0);
}
